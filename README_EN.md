# NoesisDemo - TypeScript-Based NoesisGUI Development Solution

<div align="center">

**Unreal Engine 5.4 + NoesisGUI + PuerTS**

*Develop XAML UIs elegantly with TypeScript*

English | [简体中文](README.md)

</div>

---

## 📖 Project Overview

This is an **Unreal Engine 5.4** demo project showcasing how to write **NoesisGUI** ViewModes using **TypeScript**, achieving complete MVVM data binding.

Traditional NoesisGUI development requires writing ViewModes in Blueprint or C++. This project leverages **PuerTS**'s [`uclass_extends`](https://puerts.github.io/docs/puerts/unreal/uclass_extends/) feature, enabling developers to write ViewModes in TypeScript and enjoy the many benefits of **code-based development**.

### 📚 Related Documentation

- **PuerTS UClass Extends**: [https://puerts.github.io/docs/puerts/unreal/uclass_extends/](https://puerts.github.io/docs/puerts/unreal/uclass_extends/)
- **NoesisGUI Property Change Notifications**: [https://www.noesisengine.com/docs/Gui.Core.UnrealTutorial.html#property-change-notifications](https://www.noesisengine.com/docs/Gui.Core.UnrealTutorial.html#property-change-notifications)

### ✨ Core Features

- ✅ **Perfect Recreation of Official Samples**: Successfully recreated NoesisGUI's official **Buttons** and **QuestLog** samples using TypeScript
- 🚀 **TypeScript-Based ViewModes**: Use PuerTS's `uclass_extends` to inherit UE classes and auto-generate Blueprints
- 🔧 **Dynamic DataContext Setting**: Custom `UNoesisViewModeInstance` solves official limitations
- 🤖 **AI-Friendly**: Both XAML and ViewModes are code, easily understood and generated by AI
- 📦 **Version Control Friendly**: Fully code-based, say goodbye to Blueprint merge conflicts
- ⚡ **Automatic Property Notifications**: NoesisProxy automatically handles PropertyChanged, supports TArray and TMap

---

## 🎯 Why Choose This Solution?

### Pain Points of Traditional Blueprint Approach

1. **Merge Conflict Nightmare**: Blueprint file merge conflicts are difficult to resolve, hindering team collaboration
2. **AI Cannot Understand**: AI cannot read or generate Blueprints, missing out on AI-assisted development benefits
3. **Version Control Difficulties**: Blueprint files are binary format, making diff and code review challenging

### Advantages of TypeScript Solution

| Feature | Blueprint Approach | **TypeScript Approach** |
|---------|-------------------|------------------------|
| Merge Conflicts | ❌ Hard to resolve | ✅ Text format, easy to merge |
| AI Assistance | ❌ AI cannot understand | ✅ AI fully understands, can generate code |
| Code Review | ❌ Cannot diff | ✅ Standard Git diff |
| Type Safety | ⚠️ Partial support | ✅ Complete TypeScript type system |
| Development Efficiency | ⚠️ Visual editing | ✅ Code editor + IntelliSense |
| Version Control | ❌ Binary files | ✅ Plain text files |

---

## 🏗️ Technical Architecture

### Core Components

```
┌─────────────────────────────────────────────────────────────┐
│                    Development Workflow                       │
├─────────────────────────────────────────────────────────────┤
│  1. Designers provide XAML                                    │
│     Assets/GUI/Buttons/MainWindow.xaml                       │
│                                                               │
│  2. Developers write TypeScript ViewMode                      │
│     TypeScript/ViewMode/Buttons/TS_ButtonsViewMode.ts        │
│                                                               │
│  3. PuerTS auto-generates Blueprint class                     │
│     /Game/BluePrints/TypeScript/ViewMode/Buttons/...         │
│                                                               │
│  4. TypeScript creates instance and binds                     │
│     NoesisViewUtils.createViewMode() → NewObject()           │
│     NoesisViewUtils.createNoesisInstance()                   │
└─────────────────────────────────────────────────────────────┘
```

### Three Core Technologies

#### 1. PuerTS's `uclass_extends` - Blueprint Class Generation

```typescript
// TypeScript/ViewMode/Buttons/TS_ButtonsViewMode.ts
// View full code: https://github.com/No-needto-recall/NoesisDemo/blob/main/TypeScript/ViewMode/Buttons/TS_ButtonsViewMode.ts
import * as UE from 'ue';
import { uproperty, ufunction } from 'ue';

class TS_ButtonsViewMode extends UE.Object {
    // Static method: returns generated Blueprint class path
    static Path(): string {
        return "/Game/BluePrints/TypeScript/ViewMode/Buttons/TS_ButtonsViewMode.TS_ButtonsViewMode_C";
    }

    // Use decorator to define property, bindable in XAML
    @uproperty.uproperty(uproperty.EditAnywhere, uproperty.BlueprintReadWrite)
    TestValue: string;

    // Use decorator to define command, bindable in XAML
    @ufunction.ufunction(ufunction.BlueprintCallable)
    StartCommand(): void {
        console.log("StartCommand Clicked");
    }
}
```

**PuerTS automatically generates the corresponding Blueprint class** at path `/Game/BluePrints/TypeScript/ViewMode/Buttons/TS_ButtonsViewMode_C`

#### 2. UNoesisViewModeInstance - Solving DataContext Limitations

The official `UNoesisInstance` **does not allow dynamically setting DataContext**, so we created a custom subclass:

```cpp
// Source/NoesisViewMode/Public/NoesisViewModeInstance.h
// View full code: https://github.com/No-needto-recall/NoesisDemo/blob/main/Source/NoesisViewMode/Public/NoesisViewModeInstance.h
UCLASS()
class UNoesisViewModeInstance : public UNoesisInstance {
    GENERATED_BODY()

public:
    // Pending DataContext to be set
    UPROPERTY()
    UObject* PendingDataContext;

protected:
    // Override XamlLoaded event to set DataContext after XAML loads
    virtual void XamlLoaded_Implementation() override;
};
```

**Key Point**: Setting DataContext in the `XamlLoaded` callback ensures data binding occurs after XAML is loaded.

#### 3. NoesisProxy - Automatic Property Notifications

Uses JavaScript Proxy API to intercept property modifications and automatically trigger NoesisGUI notifications:

```typescript
// NoesisProxy.ts - View full code: https://github.com/No-needto-recall/NoesisDemo/blob/main/TypeScript/NoesisProxy.ts
// Create ViewMode
const viewMode = NoesisViewUtils.createViewMode(TS_ButtonsViewMode.Path());

// Wrap with Proxy for automatic notifications
const proxy = createNoesisProxy<TS_ButtonsViewMode>(viewMode);

// Any property modification automatically notifies NoesisGUI to update
proxy.TestValue = "New Value";  // Automatically calls NotifyPropertyChanged

// Supports TArray automatic notifications
proxy.items.Add(newItem);       // Automatically calls NotifyArrayPostAdd
proxy.items.RemoveAt(0);        // Automatically calls NotifyArrayPreRemove + NotifyArrayPostRemove

// Supports TMap automatic notifications
proxy.map.Add("key", value);    // Automatically calls NotifyMapPostAdd
```

---

## 🚀 Quick Start

### ⚠️ Platform Support

**Current version supports Windows only**
- ✅ Repository includes pre-compiled Windows Editor DLLs, ready to use
- ✅ Clone and double-click `NoesisDemo.uproject` to open the editor directly
- ⚠️ **Mac/Linux Users**: Must compile C++ code manually before use

### Requirements

- **Operating System**: Windows 10/11
- **Unreal Engine**: 5.4
- **NoesisGUI Plugin**: 3.2+
- **PuerTS Plugin**: Latest version
- **TypeScript**: Global `tsc` command required
- **Visual Studio** (Optional): Required only when modifying C++ code
- **Noesis Studio** (Optional): For XAML visual design, see [Noesis Studio with Unreal](https://www.noesisengine.com/forums/viewtopic.php?t=3610)

### 📦 Installation Steps

**Windows Users (Recommended)**:
```bash
# 1. Clone the repository
git clone https://github.com/No-needto-recall/NoesisDemo.git

# 2. Double-click NoesisDemo.uproject to open the project
# ✅ No compilation needed, ready out of the box!
```

**Mac/Linux Users**:
```bash
# 1. Clone the repository
git clone https://github.com/No-needto-recall/NoesisDemo.git

# 2. Compile C++ code (required for first use)
# Refer to Unreal Engine official documentation for platform compilation setup

# 3. Double-click NoesisDemo.uproject to open the project
```

### 🎨 Developing with Noesis Studio

This project fully supports using the official [Noesis Studio](https://www.noesisengine.com/forums/viewtopic.php?t=3610) for XAML visual development:

1. **Real-time Preview**: Edit XAML in Noesis Studio and see results instantly
2. **DataContext Binding**: Studio recognizes TypeScript-generated Blueprint classes as DataContext
3. **Seamless Integration**: Modified XAML files automatically sync to UE project

**Workflow**:
```
Designers design XAML in Noesis Studio
       ↓
Save to Assets/GUI/ directory
       ↓
UE auto-imports updates
       ↓
Developers write ViewMode logic in TypeScript
```

### Compile TypeScript

```bash
# Execute in project root
tsc

# Or use watch mode (auto-compile)
tsc --watch
```

Compiled JavaScript files output to `Content/JavaScript` directory.

### Create a Simple UI

#### 1. Create XAML File

```xaml
<!-- Assets/GUI/MyView.xaml -->
<UserControl xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
    <StackPanel>
        <TextBlock Text="{Binding Message}" FontSize="24"/>
        <Button Content="Click Me" Command="{Binding OnClick}"/>
    </StackPanel>
</UserControl>
```

#### 2. Create TypeScript ViewMode

```typescript
// TypeScript/ViewMode/MyViewMode.ts
import * as UE from 'ue';
import { uproperty, ufunction } from 'ue';

class MyViewMode extends UE.Object {
    static Path(): string {
        return "/Game/BluePrints/TypeScript/ViewMode/MyViewMode.MyViewMode_C";
    }

    @uproperty.uproperty(uproperty.EditAnywhere, uproperty.BlueprintReadWrite)
    Message: string = "Hello NoesisGUI!";

    @ufunction.ufunction(ufunction.BlueprintCallable)
    OnClick(): void {
        console.log("Button clicked!");
    }
}

export default MyViewMode;
```

#### 3. Create and Display UI in TypeScript

```typescript
import { NoesisViewUtils } from './NoesisViewUtils';
import { createNoesisProxy } from './NoesisProxy';
import MyViewMode from './ViewMode/MyViewMode';

// 1. Create ViewMode instance
const viewMode = NoesisViewUtils.createViewMode(MyViewMode.Path());

// 2. Wrap with Proxy (optional, enables automatic notifications)
const proxy = createNoesisProxy<MyViewMode>(viewMode);
proxy.Message = "Hello from TypeScript!";

// 3. Create NoesisInstance
const xamlPath = "/Game/GUI/MyView.MyView";
const instance = NoesisViewUtils.createNoesisInstance(xamlPath, viewMode, gameInstance);

// 4. Add to viewport
NoesisViewUtils.attachToViewport(instance, gameInstance);
```

---

## 📂 Project Structure

```
NoesisDemo/
├── Assets/                         # NoesisGUI resources
│   └── GUI/                        # XAML UI files
│       ├── Buttons/                # Buttons sample
│       │   ├── MainWindow.xaml
│       │   └── Resources.xaml
│       └── QuestLog/               # QuestLog sample
│           ├── MainPage.xaml
│           └── Resources.xaml
│
├── TypeScript/                     # TypeScript source code
│   ├── main.ts                     # PuerTS entry point
│   ├── NoesisProxy.ts              # Automatic property notification Proxy
│   ├── NoesisViewUtils.ts          # View creation utility class
│   ├── ScriptCallHandler.ts        # C++ call router
│   └── ViewMode/                   # ViewMode implementations
│       ├── Buttons/
│       │   └── TS_ButtonsViewMode.ts
│       └── QuestLog/
│           ├── TS_QuestLogViewMode.ts
│           └── TS_Quest.ts
│
├── Source/                         # C++ source code
│   ├── NoesisDemo/                 # Main game module
│   │   ├── NoesisDemoGameInstance.h/cpp
│   │   └── NoesisDemoPuertsSubsystem.h/cpp
│   └── NoesisViewMode/             # ViewMode framework module
│       ├── NoesisViewModeInstance.h/cpp      # Custom Instance
│       └── NoesisNotifyHelperLibrary.h/cpp   # Property notification API
│
├── Content/
│   ├── JavaScript/                 # Compiled JS (tsc output)
│   ├── GUI/                        # Imported XAML resources
│   └── BluePrints/
│       └── TypeScript/ViewMode/    # PuerTS-generated Blueprint classes
│
└── Typing/                         # TypeScript type definitions (PuerTS-generated)
```

---

## 🎨 Sample Descriptions

### Buttons Sample

Recreation of NoesisGUI's official Buttons sample, demonstrating:
- Basic property binding
- Command binding
- XAML animations and styles

**XAML Binding:**
```xaml
<Button Content="START" Command="{Binding StartCommand}"/>
<Button Content="SETTINGS" Command="{Binding SettingsCommand}"/>
<Button Content="EXIT" Command="{Binding ExitCommand}"/>
```

**TypeScript ViewMode:**
```typescript
@ufunction.ufunction(ufunction.BlueprintCallable)
StartCommand(): void {
    console.log("StartCommand Clicked");
}
```

### QuestLog Sample

Recreation of NoesisGUI's official QuestLog sample, demonstrating:
- **TArray Collection Binding**: Quest list
- **Complex Data Objects**: Quest class (title, image, difficulty, description, etc.)
- **Dynamic Data Operations**: AddQuest method with automatic UI updates

**TypeScript ViewMode:**
```typescript
class TS_QuestLogViewMode extends UE.Object {
    @uproperty.uproperty(uproperty.EditAnywhere, uproperty.BlueprintReadWrite)
    Quests: UE.TArray<TS_Quest>;

    @uproperty.uproperty(uproperty.EditAnywhere, uproperty.BlueprintReadWrite)
    SelectedQuest: TS_Quest;

    @ufunction.ufunction(ufunction.BlueprintCallable)
    AddQuest(Title: string, Image: UE.Texture2D, ...): TS_Quest {
        const Quest = UE.NewObject(TS_Quest);
        Quest.Initialize(Title, Image, ...);

        // Use Proxy to automatically trigger TArray update notifications
        let Proxy = createNoesisProxy<TS_QuestLogViewMode>(this);
        Proxy.Quests.Add(Quest);

        return Quest;
    }
}
```

---

## 🔧 Technical Details

### Data Binding Flow

```
1. TypeScript class definition
   TS_ButtonsViewMode extends UE.Object
   Uses @uproperty, @ufunction decorators
   ↓
2. PuerTS generates Blueprint class
   /Game/BluePrints/TypeScript/ViewMode/Buttons/TS_ButtonsViewMode_C
   ↓
3. TypeScript creates instance
   UE.Class.Load(classPath)
   UE.NewObject(ViewModeClass)
   ↓
4. Bind to NoesisInstance
   Create UNoesisViewModeInstance
   Set PendingDataContext = viewMode
   ↓
5. XAML loading completes
   XamlLoaded event triggers
   Automatically sets DataContext
   ↓
6. Data binding takes effect
   XAML Binding → ViewMode properties
   ↓
7. Property updates
   NoesisProxy intercepts → NotifyPropertyChanged → UI refreshes
```

### Property Notification API

`UNoesisNotifyHelperLibrary` provides complete property notification API:

```cpp
// Basic property notifications
NotifyPropertyChanged(Target, PropertyName);

// TArray fine-grained notifications
NotifyArrayPostAdd(Target, ArrayPropertyName);
NotifyArrayPostInsert(Target, ArrayPropertyName, Index);
NotifyArrayPreRemove(Target, ArrayPropertyName, Index);
NotifyArrayPostRemove(Target, ArrayPropertyName, Index);

// TMap fine-grained notifications (Key must be FString)
NotifyMapPostAdd(Target, MapPropertyName, Key);
NotifyMapPreRemove(Target, MapPropertyName, Key);
NotifyMapPostRemove(Target, MapPropertyName, Key);
```

NoesisProxy automatically calls these APIs; developers don't need to call them manually.

---

## ⚠️ Technical Limitations and Solutions

### PuerTS Limitations

PuerTS has the following limitations when using `uclass_extends`:

1. **Cannot Generate UStruct and UEnum**: TypeScript classes can only generate UClass (Blueprint classes), not structs or enums
2. **Can Only Access Reflected Types**: Only types marked with `USTRUCT()` and `UENUM()` can be used in TypeScript

### Solutions

#### Solution 1: Declare Structs and Enums in C++ (Recommended)

If you need to use complex structs or enums in multiple places, declare them in C++ with reflection:

```cpp
// C++ code
UENUM(BlueprintType)
enum class EQuestDifficulty : uint8 {
    Easy     UMETA(DisplayName = "Easy"),
    Normal   UMETA(DisplayName = "Normal"),
    Hard     UMETA(DisplayName = "Hard")
};

USTRUCT(BlueprintType)
struct FQuestData {
    GENERATED_BODY()

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    FString Title;

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    EQuestDifficulty Difficulty;
};
```

Then use directly in TypeScript:

```typescript
import * as UE from 'ue';

// Use C++-defined enum
let difficulty: UE.EQuestDifficulty = UE.EQuestDifficulty.Hard;

// Use C++-defined struct
let questData: UE.FQuestData = new UE.FQuestData();
questData.Title = "New Quest";
questData.Difficulty = UE.EQuestDifficulty.Easy;
```

#### Solution 2: Use String + TypeScript Enum Mapping (Flexible)

If you can work around structs and enums logically, use **String** instead of enum and define constant mappings in TypeScript. This is the approach used in the **QuestLog sample**:

```typescript
// TypeScript/ViewMode/QuestLog/TS_Quest.ts

// TypeScript enum for type constraints and IntelliSense in code
export class QuestDifficulty {
    static Easy = "Easy";
    static Normal = "Normal";
    static Hard = "Hard";
}

class TS_Quest extends UE.Object {
    // String type in Blueprint, displays directly in XAML
    @uproperty.uproperty(uproperty.EditAnywhere, uproperty.BlueprintReadWrite)
    Difficulty: string;  // Not enum, but string

    @ufunction.ufunction(ufunction.BlueprintCallable)
    Initialize(Title: string, Image: UE.Texture2D, Difficulty: string, ...): void {
        let proxy = createNoesisProxy<TS_Quest>(this);
        proxy.Difficulty = Difficulty;  // Directly assign string
    }
}
```

Usage:

```typescript
// ScriptCallHandler.ts
import { QuestDifficulty } from './ViewMode/QuestLog/TS_Quest';

// Use TypeScript enum constants for type hints
proxyViewMode.AddQuest("Nature's Uprising", Images0, QuestDifficulty.Easy, ...);
proxyViewMode.AddQuest("Calming the Wake", Images1, QuestDifficulty.Normal, ...);
proxyViewMode.AddQuest("Retaliation", Images2, QuestDifficulty.Hard, ...);
```

### Solution Comparison

| Feature | C++ Declaration | String + TS Enum |
|---------|----------------|------------------|
| Type Safety | ✅ Strong typing, UE reflection support | ⚠️ Runtime is string |
| Development Efficiency | ⚠️ Requires writing C++ code | ✅ Pure TypeScript, rapid iteration |
| Cross-language Usage | ✅ Works in C++, Blueprint, TS | ⚠️ Mainly used in TS |
| XAML Display | ⚠️ Needs converter | ✅ Displays string directly |
| Use Cases | Complex types, multi-use | Simple enums, logic layer use |

**Recommendation**: For simple enum values (like difficulty levels), use String + TS enum solution; for complex data structures or types widely used in C++ and Blueprint, use C++ declaration.

---

## ⚡ Performance Considerations

### Performance Analysis

This solution **has not been stress-tested yet**, but from an architectural perspective, it has the following performance characteristics:

#### Performance Overhead Sources

1. **Cross-language Call Overhead**
   - TypeScript ↔ C++ cross-language calls have some overhead
   - May become a bottleneck in high-frequency call scenarios (e.g., per-frame property updates)

2. **Reflection and Static Blueprint Function Calls**
   - `UNoesisNotifyHelperLibrary` notification functions are static Blueprint functions
   - Property lookup via reflection is slower than calling NoesisGUI official APIs directly in C++

3. **NoesisProxy Interception**
   - JavaScript Proxy's `set` and `get` interception adds minor overhead
   - Overhead accumulates for ViewModes with many properties

### Performance Optimization Recommendations

#### Development Phase: Prioritize TypeScript

```
┌─────────────────────────────────────────┐
│  Early Development (Recommended TS)      │
├─────────────────────────────────────────┤
│  ✅ High development efficiency, fast iteration │
│  ✅ Easy to modify and debug             │
│  ✅ AI Coding friendly, auto-generates code │
│  ✅ Version control friendly, smooth team collaboration │
│                                          │
│  ⚠️ Performance not optimized, potential overhead │
└─────────────────────────────────────────┘
```

In early development, **strongly recommend using TypeScript**:
- Quickly validate UI logic and interactions
- Fully leverage AI Coding for development efficiency
- Enjoy version control benefits of code-based approach

#### Optimization Phase: Convert to C++ Based on Performance Data

```
┌─────────────────────────────────────────┐
│  Performance Optimization Phase (Convert to C++ as needed) │
├─────────────────────────────────────────┤
│  1. Perform performance analysis, identify bottleneck ViewModes │
│  2. Convert high-frequency ViewModes to C++ │
│  3. Keep low-frequency ViewModes in TypeScript │
└─────────────────────────────────────────┘
```

**When to Consider Converting to C++**:
- ✅ ViewMode is stable and doesn't require frequent modifications
- ✅ Performance analysis shows this ViewMode is a bottleneck (high-frequency property updates)
- ✅ Project enters optimization phase, pursuing ultimate performance

**Conversion Strategy**:
```cpp
// Convert from TypeScript to C++ ViewMode
UCLASS(Blueprintable)
class UMyViewMode : public UObject {
    GENERATED_BODY()

public:
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    FString TestValue;

    UFUNCTION(BlueprintCallable)
    void UpdateValue(const FString& NewValue) {
        if (TestValue != NewValue) {
            TestValue = NewValue;
            // Directly call NoesisGUI official API, better performance
            NotifyPropertyChanged(FName("TestValue"));
        }
    }
};
```

### Performance vs Development Efficiency Trade-off

| Phase | Recommended Approach | Reason |
|-------|---------------------|--------|
| **Prototype Development** | TypeScript | Quick idea validation, AI-assisted generation |
| **Feature Development** | TypeScript | Efficient iteration, team collaboration friendly |
| **Performance Optimization** | Convert to C++ as needed | Target bottlenecks, maintain overall efficiency |
| **Production Environment** | TS + C++ Hybrid | Balance development efficiency and runtime performance |

**Core Philosophy**: Enjoy TypeScript's high efficiency in early development, then selectively convert bottleneck parts to C++ during optimization phase, rather than starting with C++ and sacrificing development efficiency.

---

## 💡 Development Suggestions

### 1. Use `tsc --watch` for Efficiency

During development, enable TypeScript's watch mode:

```bash
tsc --watch
```

This automatically compiles TypeScript files on save, eliminating manual `tsc` execution.

### 2. Leverage NoesisProxy

For frequently updated ViewModes, wrap them with NoesisProxy:

```typescript
const viewMode = NoesisViewUtils.createViewMode(viewModeClassPath);
const proxy = createNoesisProxy<TS_ButtonsViewMode>(viewMode);

// All subsequent modifications go through proxy
proxy.TestValue = "New Value";
```

### 3. Type Safety

TypeScript's type system primarily helps **during the writing phase**:

```typescript
// PuerTS generates Blueprints via decorators, Blueprint reflection info for NoesisGUI
class TS_ButtonsViewMode extends UE.Object {
    // @uproperty decorator generates Blueprint property with reflection info
    @uproperty.uproperty(uproperty.EditAnywhere, uproperty.BlueprintReadWrite)
    TestValue: string;  // TypeScript type checking works here

    // @ufunction decorator generates Blueprint function
    @ufunction.ufunction(ufunction.BlueprintCallable)
    StartCommand(): void {
        // Enjoy TypeScript's type hints and checking while writing code
    }
}
```

**Note**: TypeScript interfaces and type aliases are only effective within TS and won't generate to Blueprints. Only members decorated with `@uproperty` and `@ufunction` will be generated as Blueprint reflection info by PuerTS.

### 4. Code Reuse

Encapsulate common logic into utility functions:

```typescript
// NoesisViewUtils.ts
export class NoesisViewUtils {
    public static createViewMode(classPath: string): UE.Object | null {
        const ViewModeClass = UE.Class.Load(classPath);
        return ViewModeClass ? UE.NewObject(ViewModeClass) : null;
    }

    // ... more utility methods
}
```

---

## 🤝 Contributing

Issues and Pull Requests are welcome!

If you encounter problems or have suggestions, please let us know in [GitHub Issues](https://github.com/No-needto-recall/NoesisDemo/issues).

---

## 📄 License

This project is licensed under the MIT License.

---

## 🙏 Acknowledgments

- [NoesisGUI](https://www.noesisengine.com/) - Powerful XAML UI framework
- [PuerTS](https://github.com/Tencent/puerts) - Excellent TypeScript runtime
- [Unreal Engine](https://www.unrealengine.com/) - World-leading game engine

---

## 📞 Contact

If you have questions or suggestions, feel free to reach out:

- NoesisGUI Official Forum: [https://forums.noesisengine.com/](https://forums.noesisengine.com/)
- GitHub Issues: [https://github.com/No-needto-recall/NoesisDemo](https://github.com/No-needto-recall/NoesisDemo)

---

<div align="center">

**Develop NoesisGUI with TypeScript, enjoy the pleasure of code-based development!**

Made with ❤️ by NoesisGUI Community

</div>
