# NoesisDemo - TypeScript-Based NoesisGUI Development Solution

<div align="center">

**Unreal Engine 5.4 + NoesisGUI + PuerTS**

*Develop XAML UIs elegantly with TypeScript*

English | [ç®€ä½“ä¸­æ–‡](README.md)

</div>

---

## ğŸ“– Project Overview

This is an **Unreal Engine 5.4** demo project showcasing how to write **NoesisGUI** ViewModes using **TypeScript**, achieving complete MVVM data binding.

Traditional NoesisGUI development requires writing ViewModes in Blueprint or C++. This project leverages **PuerTS**'s [`uclass_extends`](https://puerts.github.io/docs/puerts/unreal/uclass_extends/) feature, enabling developers to write ViewModes in TypeScript and enjoy the many benefits of **code-based development**.

### ğŸ“š Related Documentation

- **PuerTS UClass Extends**: [https://puerts.github.io/docs/puerts/unreal/uclass_extends/](https://puerts.github.io/docs/puerts/unreal/uclass_extends/)
- **NoesisGUI Property Change Notifications**: [https://www.noesisengine.com/docs/Gui.Core.UnrealTutorial.html#property-change-notifications](https://www.noesisengine.com/docs/Gui.Core.UnrealTutorial.html#property-change-notifications)

### âœ¨ Core Features

- âœ… **Perfect Recreation of Official Samples**: Successfully recreated NoesisGUI's official **Buttons** and **QuestLog** samples using TypeScript
- ğŸš€ **TypeScript-Based ViewModes**: Use PuerTS's `uclass_extends` to inherit UE classes and auto-generate Blueprints
- ğŸ”§ **Dynamic DataContext Setting**: Custom `UNoesisViewModeInstance` solves official limitations
- ğŸ¤– **AI-Friendly**: Both XAML and ViewModes are code, easily understood and generated by AI
- ğŸ“¦ **Version Control Friendly**: Fully code-based, say goodbye to Blueprint merge conflicts
- âš¡ **Automatic Property Notifications**: NoesisProxy automatically handles PropertyChanged, supports TArray and TMap

---

## ğŸ¯ Why Choose This Solution?

### Pain Points of Traditional Blueprint Approach

1. **Merge Conflict Nightmare**: Blueprint file merge conflicts are difficult to resolve, hindering team collaboration
2. **AI Cannot Understand**: AI cannot read or generate Blueprints, missing out on AI-assisted development benefits
3. **Version Control Difficulties**: Blueprint files are binary format, making diff and code review challenging

### Advantages of TypeScript Solution

| Feature | Blueprint Approach | **TypeScript Approach** |
|---------|-------------------|------------------------|
| Merge Conflicts | âŒ Hard to resolve | âœ… Text format, easy to merge |
| AI Assistance | âŒ AI cannot understand | âœ… AI fully understands, can generate code |
| Code Review | âŒ Cannot diff | âœ… Standard Git diff |
| Type Safety | âš ï¸ Partial support | âœ… Complete TypeScript type system |
| Development Efficiency | âš ï¸ Visual editing | âœ… Code editor + IntelliSense |
| Version Control | âŒ Binary files | âœ… Plain text files |

---

## ğŸ—ï¸ Technical Architecture

### Core Components

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Development Workflow                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1. Designers provide XAML                                    â”‚
â”‚     Assets/GUI/Buttons/MainWindow.xaml                       â”‚
â”‚                                                               â”‚
â”‚  2. Developers write TypeScript ViewMode                      â”‚
â”‚     TypeScript/ViewMode/Buttons/TS_ButtonsViewMode.ts        â”‚
â”‚                                                               â”‚
â”‚  3. PuerTS auto-generates Blueprint class                     â”‚
â”‚     /Game/BluePrints/TypeScript/ViewMode/Buttons/...         â”‚
â”‚                                                               â”‚
â”‚  4. TypeScript creates instance and binds                     â”‚
â”‚     NoesisViewUtils.createViewMode() â†’ NewObject()           â”‚
â”‚     NoesisViewUtils.createNoesisInstance()                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Three Core Technologies

#### 1. PuerTS's `uclass_extends` - Blueprint Class Generation

```typescript
// TypeScript/ViewMode/Buttons/TS_ButtonsViewMode.ts
// View full code: https://github.com/No-needto-recall/NoesisDemo/blob/main/TypeScript/ViewMode/Buttons/TS_ButtonsViewMode.ts
import * as UE from 'ue';
import { uproperty, ufunction } from 'ue';

class TS_ButtonsViewMode extends UE.Object {
    // Static method: returns generated Blueprint class path
    static Path(): string {
        return "/Game/BluePrints/TypeScript/ViewMode/Buttons/TS_ButtonsViewMode.TS_ButtonsViewMode_C";
    }

    // Use decorator to define property, bindable in XAML
    @uproperty.uproperty(uproperty.EditAnywhere, uproperty.BlueprintReadWrite)
    TestValue: string;

    // Use decorator to define command, bindable in XAML
    @ufunction.ufunction(ufunction.BlueprintCallable)
    StartCommand(): void {
        console.log("StartCommand Clicked");
    }
}
```

**PuerTS automatically generates the corresponding Blueprint class** at path `/Game/BluePrints/TypeScript/ViewMode/Buttons/TS_ButtonsViewMode_C`

#### 2. UNoesisViewModeInstance - Solving DataContext Limitations

The official `UNoesisInstance` **does not allow dynamically setting DataContext**, so we created a custom subclass:

```cpp
// Source/NoesisViewMode/Public/NoesisViewModeInstance.h
// View full code: https://github.com/No-needto-recall/NoesisDemo/blob/main/Source/NoesisViewMode/Public/NoesisViewModeInstance.h
UCLASS()
class UNoesisViewModeInstance : public UNoesisInstance {
    GENERATED_BODY()

public:
    // Pending DataContext to be set
    UPROPERTY()
    UObject* PendingDataContext;

protected:
    // Override XamlLoaded event to set DataContext after XAML loads
    virtual void XamlLoaded_Implementation() override;
};
```

**Key Point**: Setting DataContext in the `XamlLoaded` callback ensures data binding occurs after XAML is loaded.

#### 3. NoesisProxy - Automatic Property Notifications

Uses JavaScript Proxy API to intercept property modifications and automatically trigger NoesisGUI notifications:

```typescript
// NoesisProxy.ts - View full code: https://github.com/No-needto-recall/NoesisDemo/blob/main/TypeScript/NoesisProxy.ts
// Create ViewMode
const viewMode = NoesisViewUtils.createViewMode(TS_ButtonsViewMode.Path());

// Wrap with Proxy for automatic notifications
const proxy = createNoesisProxy<TS_ButtonsViewMode>(viewMode);

// Any property modification automatically notifies NoesisGUI to update
proxy.TestValue = "New Value";  // Automatically calls NotifyPropertyChanged

// Supports TArray automatic notifications
proxy.items.Add(newItem);       // Automatically calls NotifyArrayPostAdd
proxy.items.RemoveAt(0);        // Automatically calls NotifyArrayPreRemove + NotifyArrayPostRemove

// Supports TMap automatic notifications
proxy.map.Add("key", value);    // Automatically calls NotifyMapPostAdd
```

---

## ğŸš€ Quick Start

### âš ï¸ Platform Support

**Current version supports Windows only**
- âœ… Repository includes pre-compiled Windows Editor DLLs, ready to use
- âœ… Clone and double-click `NoesisDemo.uproject` to open the editor directly
- âš ï¸ **Mac/Linux Users**: Must compile C++ code manually before use

### Requirements

- **Operating System**: Windows 10/11
- **Unreal Engine**: 5.4
- **NoesisGUI Plugin**: 3.2+
- **PuerTS Plugin**: Latest version
- **TypeScript**: Global `tsc` command required
- **Visual Studio** (Optional): Required only when modifying C++ code
- **Noesis Studio** (Optional): For XAML visual design, see [Noesis Studio with Unreal](https://www.noesisengine.com/forums/viewtopic.php?t=3610)

### ğŸ“¦ Installation Steps

**Windows Users (Recommended)**:
```bash
# 1. Clone the repository
git clone https://github.com/No-needto-recall/NoesisDemo.git

# 2. Double-click NoesisDemo.uproject to open the project
# âœ… No compilation needed, ready out of the box!
```

**Mac/Linux Users**:
```bash
# 1. Clone the repository
git clone https://github.com/No-needto-recall/NoesisDemo.git

# 2. Compile C++ code (required for first use)
# Refer to Unreal Engine official documentation for platform compilation setup

# 3. Double-click NoesisDemo.uproject to open the project
```

### ğŸ¨ Developing with Noesis Studio

This project fully supports using the official [Noesis Studio](https://www.noesisengine.com/forums/viewtopic.php?t=3610) for XAML visual development:

1. **Real-time Preview**: Edit XAML in Noesis Studio and see results instantly
2. **DataContext Binding**: Studio recognizes TypeScript-generated Blueprint classes as DataContext
3. **Seamless Integration**: Modified XAML files automatically sync to UE project

**Workflow**:
```
Designers design XAML in Noesis Studio
       â†“
Save to Assets/GUI/ directory
       â†“
UE auto-imports updates
       â†“
Developers write ViewMode logic in TypeScript
```

### Compile TypeScript

```bash
# Execute in project root
tsc

# Or use watch mode (auto-compile)
tsc --watch
```

Compiled JavaScript files output to `Content/JavaScript` directory.

### Create a Simple UI

#### 1. Create XAML File

```xaml
<!-- Assets/GUI/MyView.xaml -->
<UserControl xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
    <StackPanel>
        <TextBlock Text="{Binding Message}" FontSize="24"/>
        <Button Content="Click Me" Command="{Binding OnClick}"/>
    </StackPanel>
</UserControl>
```

#### 2. Create TypeScript ViewMode

```typescript
// TypeScript/ViewMode/MyViewMode.ts
import * as UE from 'ue';
import { uproperty, ufunction } from 'ue';

class MyViewMode extends UE.Object {
    static Path(): string {
        return "/Game/BluePrints/TypeScript/ViewMode/MyViewMode.MyViewMode_C";
    }

    @uproperty.uproperty(uproperty.EditAnywhere, uproperty.BlueprintReadWrite)
    Message: string = "Hello NoesisGUI!";

    @ufunction.ufunction(ufunction.BlueprintCallable)
    OnClick(): void {
        console.log("Button clicked!");
    }
}

export default MyViewMode;
```

#### 3. Create and Display UI in TypeScript

```typescript
import { NoesisViewUtils } from './NoesisViewUtils';
import { createNoesisProxy } from './NoesisProxy';
import MyViewMode from './ViewMode/MyViewMode';

// 1. Create ViewMode instance
const viewMode = NoesisViewUtils.createViewMode(MyViewMode.Path());

// 2. Wrap with Proxy (optional, enables automatic notifications)
const proxy = createNoesisProxy<MyViewMode>(viewMode);
proxy.Message = "Hello from TypeScript!";

// 3. Create NoesisInstance
const xamlPath = "/Game/GUI/MyView.MyView";
const instance = NoesisViewUtils.createNoesisInstance(xamlPath, viewMode, gameInstance);

// 4. Add to viewport
NoesisViewUtils.attachToViewport(instance, gameInstance);
```

---

## ğŸ“‚ Project Structure

```
NoesisDemo/
â”œâ”€â”€ Assets/                         # NoesisGUI resources
â”‚   â””â”€â”€ GUI/                        # XAML UI files
â”‚       â”œâ”€â”€ Buttons/                # Buttons sample
â”‚       â”‚   â”œâ”€â”€ MainWindow.xaml
â”‚       â”‚   â””â”€â”€ Resources.xaml
â”‚       â””â”€â”€ QuestLog/               # QuestLog sample
â”‚           â”œâ”€â”€ MainPage.xaml
â”‚           â””â”€â”€ Resources.xaml
â”‚
â”œâ”€â”€ TypeScript/                     # TypeScript source code
â”‚   â”œâ”€â”€ main.ts                     # PuerTS entry point
â”‚   â”œâ”€â”€ NoesisProxy.ts              # Automatic property notification Proxy
â”‚   â”œâ”€â”€ NoesisViewUtils.ts          # View creation utility class
â”‚   â”œâ”€â”€ ScriptCallHandler.ts        # C++ call router
â”‚   â””â”€â”€ ViewMode/                   # ViewMode implementations
â”‚       â”œâ”€â”€ Buttons/
â”‚       â”‚   â””â”€â”€ TS_ButtonsViewMode.ts
â”‚       â””â”€â”€ QuestLog/
â”‚           â”œâ”€â”€ TS_QuestLogViewMode.ts
â”‚           â””â”€â”€ TS_Quest.ts
â”‚
â”œâ”€â”€ Source/                         # C++ source code
â”‚   â”œâ”€â”€ NoesisDemo/                 # Main game module
â”‚   â”‚   â”œâ”€â”€ NoesisDemoGameInstance.h/cpp
â”‚   â”‚   â””â”€â”€ NoesisDemoPuertsSubsystem.h/cpp
â”‚   â””â”€â”€ NoesisViewMode/             # ViewMode framework module
â”‚       â”œâ”€â”€ NoesisViewModeInstance.h/cpp      # Custom Instance
â”‚       â””â”€â”€ NoesisNotifyHelperLibrary.h/cpp   # Property notification API
â”‚
â”œâ”€â”€ Content/
â”‚   â”œâ”€â”€ JavaScript/                 # Compiled JS (tsc output)
â”‚   â”œâ”€â”€ GUI/                        # Imported XAML resources
â”‚   â””â”€â”€ BluePrints/
â”‚       â””â”€â”€ TypeScript/ViewMode/    # PuerTS-generated Blueprint classes
â”‚
â””â”€â”€ Typing/                         # TypeScript type definitions (PuerTS-generated)
```

---

## ğŸ¨ Sample Descriptions

### Buttons Sample

Recreation of NoesisGUI's official Buttons sample, demonstrating:
- Basic property binding
- Command binding
- XAML animations and styles

**XAML Binding:**
```xaml
<Button Content="START" Command="{Binding StartCommand}"/>
<Button Content="SETTINGS" Command="{Binding SettingsCommand}"/>
<Button Content="EXIT" Command="{Binding ExitCommand}"/>
```

**TypeScript ViewMode:**
```typescript
@ufunction.ufunction(ufunction.BlueprintCallable)
StartCommand(): void {
    console.log("StartCommand Clicked");
}
```

### QuestLog Sample

Recreation of NoesisGUI's official QuestLog sample, demonstrating:
- **TArray Collection Binding**: Quest list
- **Complex Data Objects**: Quest class (title, image, difficulty, description, etc.)
- **Dynamic Data Operations**: AddQuest method with automatic UI updates

**TypeScript ViewMode:**
```typescript
class TS_QuestLogViewMode extends UE.Object {
    @uproperty.uproperty(uproperty.EditAnywhere, uproperty.BlueprintReadWrite)
    Quests: UE.TArray<TS_Quest>;

    @uproperty.uproperty(uproperty.EditAnywhere, uproperty.BlueprintReadWrite)
    SelectedQuest: TS_Quest;

    @ufunction.ufunction(ufunction.BlueprintCallable)
    AddQuest(Title: string, Image: UE.Texture2D, ...): TS_Quest {
        const Quest = UE.NewObject(TS_Quest);
        Quest.Initialize(Title, Image, ...);

        // Use Proxy to automatically trigger TArray update notifications
        let Proxy = createNoesisProxy<TS_QuestLogViewMode>(this);
        Proxy.Quests.Add(Quest);

        return Quest;
    }
}
```

---

## ğŸ”§ Technical Details

### Data Binding Flow

```
1. TypeScript class definition
   TS_ButtonsViewMode extends UE.Object
   Uses @uproperty, @ufunction decorators
   â†“
2. PuerTS generates Blueprint class
   /Game/BluePrints/TypeScript/ViewMode/Buttons/TS_ButtonsViewMode_C
   â†“
3. TypeScript creates instance
   UE.Class.Load(classPath)
   UE.NewObject(ViewModeClass)
   â†“
4. Bind to NoesisInstance
   Create UNoesisViewModeInstance
   Set PendingDataContext = viewMode
   â†“
5. XAML loading completes
   XamlLoaded event triggers
   Automatically sets DataContext
   â†“
6. Data binding takes effect
   XAML Binding â†’ ViewMode properties
   â†“
7. Property updates
   NoesisProxy intercepts â†’ NotifyPropertyChanged â†’ UI refreshes
```

### Property Notification API

`UNoesisNotifyHelperLibrary` provides complete property notification API:

```cpp
// Basic property notifications
NotifyPropertyChanged(Target, PropertyName);

// TArray fine-grained notifications
NotifyArrayPostAdd(Target, ArrayPropertyName);
NotifyArrayPostInsert(Target, ArrayPropertyName, Index);
NotifyArrayPreRemove(Target, ArrayPropertyName, Index);
NotifyArrayPostRemove(Target, ArrayPropertyName, Index);

// TMap fine-grained notifications (Key must be FString)
NotifyMapPostAdd(Target, MapPropertyName, Key);
NotifyMapPreRemove(Target, MapPropertyName, Key);
NotifyMapPostRemove(Target, MapPropertyName, Key);
```

NoesisProxy automatically calls these APIs; developers don't need to call them manually.

---

## âš ï¸ Technical Limitations and Solutions

### PuerTS Limitations

PuerTS has the following limitations when using `uclass_extends`:

1. **Cannot Generate UStruct and UEnum**: TypeScript classes can only generate UClass (Blueprint classes), not structs or enums
2. **Can Only Access Reflected Types**: Only types marked with `USTRUCT()` and `UENUM()` can be used in TypeScript

### Solutions

#### Solution 1: Declare Structs and Enums in C++ (Recommended)

If you need to use complex structs or enums in multiple places, declare them in C++ with reflection:

```cpp
// C++ code
UENUM(BlueprintType)
enum class EQuestDifficulty : uint8 {
    Easy     UMETA(DisplayName = "Easy"),
    Normal   UMETA(DisplayName = "Normal"),
    Hard     UMETA(DisplayName = "Hard")
};

USTRUCT(BlueprintType)
struct FQuestData {
    GENERATED_BODY()

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    FString Title;

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    EQuestDifficulty Difficulty;
};
```

Then use directly in TypeScript:

```typescript
import * as UE from 'ue';

// Use C++-defined enum
let difficulty: UE.EQuestDifficulty = UE.EQuestDifficulty.Hard;

// Use C++-defined struct
let questData: UE.FQuestData = new UE.FQuestData();
questData.Title = "New Quest";
questData.Difficulty = UE.EQuestDifficulty.Easy;
```

#### Solution 2: Use String + TypeScript Enum Mapping (Flexible)

If you can work around structs and enums logically, use **String** instead of enum and define constant mappings in TypeScript. This is the approach used in the **QuestLog sample**:

```typescript
// TypeScript/ViewMode/QuestLog/TS_Quest.ts

// TypeScript enum for type constraints and IntelliSense in code
export class QuestDifficulty {
    static Easy = "Easy";
    static Normal = "Normal";
    static Hard = "Hard";
}

class TS_Quest extends UE.Object {
    // String type in Blueprint, displays directly in XAML
    @uproperty.uproperty(uproperty.EditAnywhere, uproperty.BlueprintReadWrite)
    Difficulty: string;  // Not enum, but string

    @ufunction.ufunction(ufunction.BlueprintCallable)
    Initialize(Title: string, Image: UE.Texture2D, Difficulty: string, ...): void {
        let proxy = createNoesisProxy<TS_Quest>(this);
        proxy.Difficulty = Difficulty;  // Directly assign string
    }
}
```

Usage:

```typescript
// ScriptCallHandler.ts
import { QuestDifficulty } from './ViewMode/QuestLog/TS_Quest';

// Use TypeScript enum constants for type hints
proxyViewMode.AddQuest("Nature's Uprising", Images0, QuestDifficulty.Easy, ...);
proxyViewMode.AddQuest("Calming the Wake", Images1, QuestDifficulty.Normal, ...);
proxyViewMode.AddQuest("Retaliation", Images2, QuestDifficulty.Hard, ...);
```

### Solution Comparison

| Feature | C++ Declaration | String + TS Enum |
|---------|----------------|------------------|
| Type Safety | âœ… Strong typing, UE reflection support | âš ï¸ Runtime is string |
| Development Efficiency | âš ï¸ Requires writing C++ code | âœ… Pure TypeScript, rapid iteration |
| Cross-language Usage | âœ… Works in C++, Blueprint, TS | âš ï¸ Mainly used in TS |
| XAML Display | âš ï¸ Needs converter | âœ… Displays string directly |
| Use Cases | Complex types, multi-use | Simple enums, logic layer use |

**Recommendation**: For simple enum values (like difficulty levels), use String + TS enum solution; for complex data structures or types widely used in C++ and Blueprint, use C++ declaration.

---

## âš¡ Performance Considerations

### Performance Analysis

This solution **has not been stress-tested yet**, but from an architectural perspective, it has the following performance characteristics:

#### Performance Overhead Sources

1. **Cross-language Call Overhead**
   - TypeScript â†” C++ cross-language calls have some overhead
   - May become a bottleneck in high-frequency call scenarios (e.g., per-frame property updates)

2. **Reflection and Static Blueprint Function Calls**
   - `UNoesisNotifyHelperLibrary` notification functions are static Blueprint functions
   - Property lookup via reflection is slower than calling NoesisGUI official APIs directly in C++

3. **NoesisProxy Interception**
   - JavaScript Proxy's `set` and `get` interception adds minor overhead
   - Overhead accumulates for ViewModes with many properties

### Performance Optimization Recommendations

#### Development Phase: Prioritize TypeScript

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Early Development (Recommended TS)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  âœ… High development efficiency, fast iteration â”‚
â”‚  âœ… Easy to modify and debug             â”‚
â”‚  âœ… AI Coding friendly, auto-generates code â”‚
â”‚  âœ… Version control friendly, smooth team collaboration â”‚
â”‚                                          â”‚
â”‚  âš ï¸ Performance not optimized, potential overhead â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

In early development, **strongly recommend using TypeScript**:
- Quickly validate UI logic and interactions
- Fully leverage AI Coding for development efficiency
- Enjoy version control benefits of code-based approach

#### Optimization Phase: Convert to C++ Based on Performance Data

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Performance Optimization Phase (Convert to C++ as needed) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1. Perform performance analysis, identify bottleneck ViewModes â”‚
â”‚  2. Convert high-frequency ViewModes to C++ â”‚
â”‚  3. Keep low-frequency ViewModes in TypeScript â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**When to Consider Converting to C++**:
- âœ… ViewMode is stable and doesn't require frequent modifications
- âœ… Performance analysis shows this ViewMode is a bottleneck (high-frequency property updates)
- âœ… Project enters optimization phase, pursuing ultimate performance

**Conversion Strategy**:
```cpp
// Convert from TypeScript to C++ ViewMode
UCLASS(Blueprintable)
class UMyViewMode : public UObject {
    GENERATED_BODY()

public:
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    FString TestValue;

    UFUNCTION(BlueprintCallable)
    void UpdateValue(const FString& NewValue) {
        if (TestValue != NewValue) {
            TestValue = NewValue;
            // Directly call NoesisGUI official API, better performance
            NotifyPropertyChanged(FName("TestValue"));
        }
    }
};
```

### Performance vs Development Efficiency Trade-off

| Phase | Recommended Approach | Reason |
|-------|---------------------|--------|
| **Prototype Development** | TypeScript | Quick idea validation, AI-assisted generation |
| **Feature Development** | TypeScript | Efficient iteration, team collaboration friendly |
| **Performance Optimization** | Convert to C++ as needed | Target bottlenecks, maintain overall efficiency |
| **Production Environment** | TS + C++ Hybrid | Balance development efficiency and runtime performance |

**Core Philosophy**: Enjoy TypeScript's high efficiency in early development, then selectively convert bottleneck parts to C++ during optimization phase, rather than starting with C++ and sacrificing development efficiency.

---

## ğŸ’¡ Development Suggestions

### 1. Use `tsc --watch` for Efficiency

During development, enable TypeScript's watch mode:

```bash
tsc --watch
```

This automatically compiles TypeScript files on save, eliminating manual `tsc` execution.

### 2. Leverage NoesisProxy

For frequently updated ViewModes, wrap them with NoesisProxy:

```typescript
const viewMode = NoesisViewUtils.createViewMode(viewModeClassPath);
const proxy = createNoesisProxy<TS_ButtonsViewMode>(viewMode);

// All subsequent modifications go through proxy
proxy.TestValue = "New Value";
```

### 3. Type Safety

TypeScript's type system primarily helps **during the writing phase**:

```typescript
// PuerTS generates Blueprints via decorators, Blueprint reflection info for NoesisGUI
class TS_ButtonsViewMode extends UE.Object {
    // @uproperty decorator generates Blueprint property with reflection info
    @uproperty.uproperty(uproperty.EditAnywhere, uproperty.BlueprintReadWrite)
    TestValue: string;  // TypeScript type checking works here

    // @ufunction decorator generates Blueprint function
    @ufunction.ufunction(ufunction.BlueprintCallable)
    StartCommand(): void {
        // Enjoy TypeScript's type hints and checking while writing code
    }
}
```

**Note**: TypeScript interfaces and type aliases are only effective within TS and won't generate to Blueprints. Only members decorated with `@uproperty` and `@ufunction` will be generated as Blueprint reflection info by PuerTS.

### 4. Code Reuse

Encapsulate common logic into utility functions:

```typescript
// NoesisViewUtils.ts
export class NoesisViewUtils {
    public static createViewMode(classPath: string): UE.Object | null {
        const ViewModeClass = UE.Class.Load(classPath);
        return ViewModeClass ? UE.NewObject(ViewModeClass) : null;
    }

    // ... more utility methods
}
```

---

## ğŸ¤ Contributing

Issues and Pull Requests are welcome!

If you encounter problems or have suggestions, please let us know in [GitHub Issues](https://github.com/No-needto-recall/NoesisDemo/issues).

---

## ğŸ“„ License

This project is licensed under the MIT License.

---

## ğŸ™ Acknowledgments

- [NoesisGUI](https://www.noesisengine.com/) - Powerful XAML UI framework
- [PuerTS](https://github.com/Tencent/puerts) - Excellent TypeScript runtime
- [Unreal Engine](https://www.unrealengine.com/) - World-leading game engine

---

## ğŸ“ Contact

If you have questions or suggestions, feel free to reach out:

- NoesisGUI Official Forum: [https://forums.noesisengine.com/](https://forums.noesisengine.com/)
- GitHub Issues: [https://github.com/No-needto-recall/NoesisDemo](https://github.com/No-needto-recall/NoesisDemo)

---

<div align="center">

**Develop NoesisGUI with TypeScript, enjoy the pleasure of code-based development!**

Made with â¤ï¸ by NoesisGUI Community

</div>
