# NoesisDemo - TypeScript-Based NoesisGUI Development Solution

<div align="center">

**Unreal Engine 5.4 + NoesisGUI + PuerTS**

*Develop XAML UIs elegantly with TypeScript*

English | [ç®€ä½“ä¸­æ–‡](README.md)

</div>

---

## ğŸ“‘ Table of Contents

- [Project Overview](#-project-overview)
- [Core Features](#-core-features)
- [Quick Start](#-quick-start)
  - [Requirements](#requirements)
  - [Getting the Project](#-getting-the-project)
  - [Compile TypeScript](#compile-typescript)
  - [Create a Simple UI](#create-a-simple-ui)
- [Sample Descriptions](#-sample-descriptions)
- [Technical Architecture](#ï¸-technical-architecture)
  - [Core Components](#core-components)
  - [Data Binding Flow](#data-binding-flow)
  - [Three Core Technologies](#three-core-technologies)
- [Project Structure](#-project-structure)
- [Technical Details](#-technical-details)
  - [Property Notification API](#property-notification-api)
  - [Technical Limitations and Solutions](#ï¸-technical-limitations-and-solutions)
- [Performance Considerations](#-performance-considerations)
- [Development Suggestions](#-development-suggestions)
- [Contributing and Contact](#-contributing-and-contact)

---

## ğŸ“– Project Overview

This is an **Unreal Engine 5.4** demo project showcasing how to write **NoesisGUI** ViewModes using **TypeScript**, achieving complete MVVM data binding.

Traditional NoesisGUI development requires writing ViewModes in Blueprint or C++. This project leverages **PuerTS**'s [`uclass_extends`](https://puerts.github.io/docs/puerts/unreal/uclass_extends/) feature, enabling developers to write ViewModes in TypeScript and enjoy the many benefits of **code-based development**.

### ğŸ“š Related Documentation

- **PuerTS UClass Extends**: [https://puerts.github.io/docs/puerts/unreal/uclass_extends/](https://puerts.github.io/docs/puerts/unreal/uclass_extends/)
- **NoesisGUI Property Change Notifications**: [https://www.noesisengine.com/docs/Gui.Core.UnrealTutorial.html#property-change-notifications](https://www.noesisengine.com/docs/Gui.Core.UnrealTutorial.html#property-change-notifications)

---

## âœ¨ Core Features

- âœ… **Perfect Recreation of Official Samples**: Successfully recreated NoesisGUI's official **Buttons** and **QuestLog** samples using TypeScript
- ğŸš€ **TypeScript-Based ViewModes**: Use PuerTS's `uclass_extends` to inherit UE classes and auto-generate Blueprints
- ğŸ”§ **Dynamic DataContext Setting**: Custom `UNoesisViewModeInstance` solves official limitations
- ğŸ¤– **AI-Friendly**: Both XAML and ViewModes are code, easily understood and generated by AI
- ğŸ“¦ **Version Control Friendly**: Fully code-based, say goodbye to Blueprint merge conflicts
- âš¡ **Automatic Property Notifications**: NoesisProxy automatically handles PropertyChanged, supports TArray and TMap

### Why Choose the TypeScript Solution?

Pain points of traditional Blueprint approach:
- âŒ **Hard to resolve merge conflicts**: Blueprints are binary files, making merge conflicts difficult
- âŒ **AI cannot understand**: AI cannot read or generate Blueprints
- âŒ **Version control difficulties**: Hard to perform diff and code review

Advantages of TypeScript solution:
- âœ… **Text format, easy to merge**: Standard Git version control
- âœ… **AI fully understands**: Enjoy AI-assisted development
- âœ… **Complete type system**: TypeScript type checking and IntelliSense
- âœ… **Code review friendly**: Standard Git diff, facilitates team collaboration

---

## ğŸš€ Quick Start

### âš ï¸ Platform Support

**Current version supports Windows only**
- âœ… Repository includes pre-compiled Windows Editor DLLs, ready to use
- âœ… Clone and double-click `NoesisDemo.uproject` to open the editor directly
- âš ï¸ **Mac/Linux Users**: Must compile C++ code manually before use

### Requirements

- **Operating System**: Windows 10/11
- **Unreal Engine**: 5.4
- **NoesisGUI Plugin**: 3.2+
- **PuerTS Plugin**: Latest version
- **TypeScript**: Global `tsc` command required
- **Visual Studio** (Optional): Required only when modifying C++ code
- **Noesis Studio** (Optional): For XAML visual design, see [Noesis Studio with Unreal](https://www.noesisengine.com/forums/viewtopic.php?t=3610)

### ğŸ“¦ Getting the Project

```bash
# Clone the repository
git clone https://github.com/No-needto-recall/NoesisDemo.git

# Double-click NoesisDemo.uproject to open the project
# âœ… No compilation needed, ready out of the box!
```

**Mac/Linux Users**:
```bash
# 1. Clone the repository
git clone https://github.com/No-needto-recall/NoesisDemo.git

# 2. Compile C++ code (required for first use)
# Refer to Unreal Engine official documentation for platform compilation setup

# 3. Double-click NoesisDemo.uproject to open the project
```

### ğŸ¨ Developing with Noesis Studio

This project fully supports using the official [Noesis Studio](https://www.noesisengine.com/forums/viewtopic.php?t=3610) for XAML visual development:

1. **Real-time Preview**: Edit XAML in Noesis Studio and see results instantly
2. **DataContext Binding**: Studio recognizes TypeScript-generated Blueprint classes as DataContext
3. **Seamless Integration**: Modified XAML files automatically sync to UE project

**Workflow**:
```
Designers design XAML in Noesis Studio
       â†“
Save to Assets/GUI/ directory
       â†“
UE auto-imports updates
       â†“
Developers write ViewMode logic in TypeScript
```

### Compile TypeScript

```bash
# Execute in project root
tsc

# Or use watch mode (auto-compile)
tsc --watch
```

Compiled JavaScript files output to `Content/JavaScript` directory.

### Create a Simple UI

#### 1. Create XAML File

```xaml
<!-- Assets/GUI/MyView.xaml -->
<UserControl xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
    <StackPanel>
        <TextBlock Text="{Binding Message}" FontSize="24"/>
        <Button Content="Click Me" Command="{Binding OnClick}"/>
    </StackPanel>
</UserControl>
```

#### 2. Create TypeScript ViewMode

```typescript
// TypeScript/ViewMode/MyViewMode.ts
import * as UE from 'ue';
import { uproperty, ufunction } from 'ue';

class MyViewMode extends UE.Object {
    static Path(): string {
        return "/Game/BluePrints/TypeScript/ViewMode/MyViewMode.MyViewMode_C";
    }

    @uproperty.uproperty(uproperty.EditAnywhere, uproperty.BlueprintReadWrite)
    Message: string = "Hello NoesisGUI!";

    @ufunction.ufunction(ufunction.BlueprintCallable)
    OnClick(): void {
        console.log("Button clicked!");
    }
}

export default MyViewMode;
```

#### 3. Create and Display UI in TypeScript

```typescript
import { NoesisViewUtils } from './NoesisViewUtils';
import { createNoesisProxy } from './NoesisProxy';
import MyViewMode from './ViewMode/MyViewMode';

// 1. Create ViewMode instance
const viewMode = NoesisViewUtils.createViewMode(MyViewMode.Path());

// 2. Wrap with Proxy (optional, enables automatic notifications)
const proxy = createNoesisProxy<MyViewMode>(viewMode);
proxy.Message = "Hello from TypeScript!";

// 3. Create NoesisInstance
const xamlPath = "/Game/GUI/MyView.MyView";
const instance = NoesisViewUtils.createNoesisInstance(xamlPath, viewMode, gameInstance);

// 4. Add to viewport
NoesisViewUtils.attachToViewport(instance, gameInstance);
```

---

## ğŸ¨ Sample Descriptions

### Buttons Sample

Recreation of NoesisGUI's official Buttons sample, demonstrating:
- Basic property binding
- Command binding
- XAML animations and styles

**XAML Binding:**
```xaml
<Button Content="START" Command="{Binding StartCommand}"/>
<Button Content="SETTINGS" Command="{Binding SettingsCommand}"/>
<Button Content="EXIT" Command="{Binding ExitCommand}"/>
```

**TypeScript ViewMode:**
```typescript
@ufunction.ufunction(ufunction.BlueprintCallable)
StartCommand(): void {
    console.log("StartCommand Clicked");
}
```

### QuestLog Sample

Recreation of NoesisGUI's official QuestLog sample, demonstrating:
- **TArray Collection Binding**: Quest list
- **Complex Data Objects**: Quest class (title, image, difficulty, description, etc.)
- **Dynamic Data Operations**: AddQuest method with automatic UI updates

**TypeScript ViewMode:**
```typescript
class TS_QuestLogViewMode extends UE.Object {
    @uproperty.uproperty(uproperty.EditAnywhere, uproperty.BlueprintReadWrite)
    Quests: UE.TArray<TS_Quest>;

    @uproperty.uproperty(uproperty.EditAnywhere, uproperty.BlueprintReadWrite)
    SelectedQuest: TS_Quest;

    @ufunction.ufunction(ufunction.BlueprintCallable)
    AddQuest(Title: string, Image: UE.Texture2D, ...): TS_Quest {
        const Quest = UE.NewObject(TS_Quest);
        Quest.Initialize(Title, Image, ...);

        // Use Proxy to automatically trigger TArray update notifications
        let Proxy = createNoesisProxy<TS_QuestLogViewMode>(this);
        Proxy.Quests.Add(Quest);

        return Quest;
    }
}
```

---

## ğŸ—ï¸ Technical Architecture

### Core Components

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Development Workflow                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1. Designers provide XAML                                    â”‚
â”‚     Assets/GUI/Buttons/MainWindow.xaml                       â”‚
â”‚                                                               â”‚
â”‚  2. Developers write TypeScript ViewMode                      â”‚
â”‚     TypeScript/ViewMode/Buttons/TS_ButtonsViewMode.ts        â”‚
â”‚                                                               â”‚
â”‚  3. PuerTS auto-generates Blueprint class                     â”‚
â”‚     /Game/BluePrints/TypeScript/ViewMode/Buttons/...         â”‚
â”‚                                                               â”‚
â”‚  4. TypeScript creates instance and binds                     â”‚
â”‚     NoesisViewUtils.createViewMode() â†’ NewObject()           â”‚
â”‚     NoesisViewUtils.createNoesisInstance()                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Data Binding Flow

```
1. TypeScript class definition
   TS_ButtonsViewMode extends UE.Object
   Uses @uproperty, @ufunction decorators
   â†“
2. PuerTS generates Blueprint class
   /Game/BluePrints/TypeScript/ViewMode/Buttons/TS_ButtonsViewMode_C
   â†“
3. TypeScript creates instance
   UE.Class.Load(classPath)
   UE.NewObject(ViewModeClass)
   â†“
4. Bind to NoesisInstance
   Create UNoesisViewModeInstance
   Set PendingDataContext = viewMode
   â†“
5. XAML loading completes
   XamlLoaded event triggers
   Automatically sets DataContext
   â†“
6. Data binding takes effect
   XAML Binding â†’ ViewMode properties
   â†“
7. Property updates
   NoesisProxy intercepts â†’ NotifyPropertyChanged â†’ UI refreshes
```

### Three Core Technologies

#### 1. PuerTS's `uclass_extends` - Blueprint Class Generation

```typescript
// TypeScript/ViewMode/Buttons/TS_ButtonsViewMode.ts
// View full code: https://github.com/No-needto-recall/NoesisDemo/blob/main/TypeScript/ViewMode/Buttons/TS_ButtonsViewMode.ts
import * as UE from 'ue';
import { uproperty, ufunction } from 'ue';

class TS_ButtonsViewMode extends UE.Object {
    // Static method: returns generated Blueprint class path
    static Path(): string {
        return "/Game/BluePrints/TypeScript/ViewMode/Buttons/TS_ButtonsViewMode.TS_ButtonsViewMode_C";
    }

    // Use decorator to define property, bindable in XAML
    @uproperty.uproperty(uproperty.EditAnywhere, uproperty.BlueprintReadWrite)
    TestValue: string;

    // Use decorator to define command, bindable in XAML
    @ufunction.ufunction(ufunction.BlueprintCallable)
    StartCommand(): void {
        console.log("StartCommand Clicked");
    }
}
```

**PuerTS automatically generates the corresponding Blueprint class** at path `/Game/BluePrints/TypeScript/ViewMode/Buttons/TS_ButtonsViewMode_C`

#### 2. UNoesisViewModeInstance - Solving DataContext Limitations

The official `UNoesisInstance` **does not allow dynamically setting DataContext**, so we created a custom subclass:

```cpp
// Source/NoesisViewMode/Public/NoesisViewModeInstance.h
// View full code: https://github.com/No-needto-recall/NoesisDemo/blob/main/Source/NoesisViewMode/Public/NoesisViewModeInstance.h
UCLASS()
class UNoesisViewModeInstance : public UNoesisInstance {
    GENERATED_BODY()

public:
    // Pending DataContext to be set
    UPROPERTY()
    UObject* PendingDataContext;

protected:
    // Override XamlLoaded event to set DataContext after XAML loads
    virtual void XamlLoaded_Implementation() override;
};
```

**Key Point**: Setting DataContext in the `XamlLoaded` callback ensures data binding occurs after XAML is loaded.

#### 3. NoesisProxy - Automatic Property Notifications

Uses JavaScript Proxy API to intercept property modifications and automatically trigger NoesisGUI notifications:

```typescript
// NoesisProxy.ts - View full code: https://github.com/No-needto-recall/NoesisDemo/blob/main/TypeScript/NoesisProxy.ts
// Create ViewMode
const viewMode = NoesisViewUtils.createViewMode(TS_ButtonsViewMode.Path());

// Wrap with Proxy for automatic notifications
const proxy = createNoesisProxy<TS_ButtonsViewMode>(viewMode);

// Any property modification automatically notifies NoesisGUI to update
proxy.TestValue = "New Value";  // Automatically calls NotifyPropertyChanged

// Supports TArray automatic notifications
proxy.items.Add(newItem);       // Automatically calls NotifyArrayPostAdd
proxy.items.RemoveAt(0);        // Automatically calls NotifyArrayPreRemove + NotifyArrayPostRemove

// Supports TMap automatic notifications
proxy.map.Add("key", value);    // Automatically calls NotifyMapPostAdd
```

---

## ğŸ“‚ Project Structure

```
NoesisDemo/
â”œâ”€â”€ Assets/                         # NoesisGUI resources
â”‚   â””â”€â”€ GUI/                        # XAML UI files
â”‚       â”œâ”€â”€ Buttons/                # Buttons sample
â”‚       â”‚   â”œâ”€â”€ MainWindow.xaml
â”‚       â”‚   â””â”€â”€ Resources.xaml
â”‚       â””â”€â”€ QuestLog/               # QuestLog sample
â”‚           â”œâ”€â”€ MainPage.xaml
â”‚           â””â”€â”€ Resources.xaml
â”‚
â”œâ”€â”€ TypeScript/                     # TypeScript source code
â”‚   â”œâ”€â”€ main.ts                     # PuerTS entry point
â”‚   â”œâ”€â”€ NoesisProxy.ts              # Automatic property notification Proxy
â”‚   â”œâ”€â”€ NoesisViewUtils.ts          # View creation utility class
â”‚   â”œâ”€â”€ ScriptCallHandler.ts        # C++ call router
â”‚   â””â”€â”€ ViewMode/                   # ViewMode implementations
â”‚       â”œâ”€â”€ Buttons/
â”‚       â”‚   â””â”€â”€ TS_ButtonsViewMode.ts
â”‚       â””â”€â”€ QuestLog/
â”‚           â”œâ”€â”€ TS_QuestLogViewMode.ts
â”‚           â””â”€â”€ TS_Quest.ts
â”‚
â”œâ”€â”€ Source/                         # C++ source code
â”‚   â”œâ”€â”€ NoesisDemo/                 # Main game module
â”‚   â”‚   â”œâ”€â”€ NoesisDemoGameInstance.h/cpp
â”‚   â”‚   â””â”€â”€ NoesisDemoPuertsSubsystem.h/cpp
â”‚   â””â”€â”€ NoesisViewMode/             # ViewMode framework module
â”‚       â”œâ”€â”€ NoesisViewModeInstance.h/cpp      # Custom Instance
â”‚       â””â”€â”€ NoesisNotifyHelperLibrary.h/cpp   # Property notification API
â”‚
â”œâ”€â”€ Content/
â”‚   â”œâ”€â”€ JavaScript/                 # Compiled JS (tsc output)
â”‚   â”œâ”€â”€ GUI/                        # Imported XAML resources
â”‚   â””â”€â”€ BluePrints/
â”‚       â””â”€â”€ TypeScript/ViewMode/    # PuerTS-generated Blueprint classes
â”‚
â””â”€â”€ Typing/                         # TypeScript type definitions (PuerTS-generated)
```

---

## ğŸ”§ Technical Details

### Property Notification API

`UNoesisNotifyHelperLibrary` provides complete property notification API:

```cpp
// Basic property notifications
NotifyPropertyChanged(Target, PropertyName);

// TArray fine-grained notifications
NotifyArrayPostAdd(Target, ArrayPropertyName);
NotifyArrayPostInsert(Target, ArrayPropertyName, Index);
NotifyArrayPreRemove(Target, ArrayPropertyName, Index);
NotifyArrayPostRemove(Target, ArrayPropertyName, Index);

// TMap fine-grained notifications (Key must be FString)
NotifyMapPostAdd(Target, MapPropertyName, Key);
NotifyMapPreRemove(Target, MapPropertyName, Key);
NotifyMapPostRemove(Target, MapPropertyName, Key);
```

NoesisProxy automatically calls these APIs; developers don't need to call them manually.

---

## âš ï¸ Technical Limitations and Solutions

### PuerTS Limitations

PuerTS has the following limitations when using `uclass_extends`:

1. **Cannot Generate UStruct and UEnum**: TypeScript classes can only generate UClass (Blueprint classes), not structs or enums
2. **Can Only Access Reflected Types**: Only types marked with `USTRUCT()` and `UENUM()` can be used in TypeScript

### Solutions

#### Solution 1: Declare Structs and Enums in C++ (Recommended)

If you need to use complex structs or enums in multiple places, declare them in C++ with reflection:

```cpp
// C++ code
UENUM(BlueprintType)
enum class EQuestDifficulty : uint8 {
    Easy     UMETA(DisplayName = "Easy"),
    Normal   UMETA(DisplayName = "Normal"),
    Hard     UMETA(DisplayName = "Hard")
};

USTRUCT(BlueprintType)
struct FQuestData {
    GENERATED_BODY()

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    FString Title;

    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    EQuestDifficulty Difficulty;
};
```

Then use directly in TypeScript:

```typescript
import * as UE from 'ue';

// Use C++-defined enum
let difficulty: UE.EQuestDifficulty = UE.EQuestDifficulty.Hard;

// Use C++-defined struct
let questData: UE.FQuestData = new UE.FQuestData();
questData.Title = "New Quest";
questData.Difficulty = UE.EQuestDifficulty.Easy;
```

#### Solution 2: Use String + TypeScript Enum Mapping (Flexible)

If you can work around structs and enums logically, use **String** instead of enum and define constant mappings in TypeScript. This is the approach used in the **QuestLog sample**:

```typescript
// TypeScript/ViewMode/QuestLog/TS_Quest.ts

// TypeScript enum for type constraints and IntelliSense in code
export class QuestDifficulty {
    static Easy = "Easy";
    static Normal = "Normal";
    static Hard = "Hard";
}

class TS_Quest extends UE.Object {
    // String type in Blueprint, displays directly in XAML
    @uproperty.uproperty(uproperty.EditAnywhere, uproperty.BlueprintReadWrite)
    Difficulty: string;  // Not enum, but string

    @ufunction.ufunction(ufunction.BlueprintCallable)
    Initialize(Title: string, Image: UE.Texture2D, Difficulty: string, ...): void {
        let proxy = createNoesisProxy<TS_Quest>(this);
        proxy.Difficulty = Difficulty;  // Directly assign string
    }
}
```

Usage:

```typescript
// ScriptCallHandler.ts
import { QuestDifficulty } from './ViewMode/QuestLog/TS_Quest';

// Use TypeScript enum constants for type hints
proxyViewMode.AddQuest("Nature's Uprising", Images0, QuestDifficulty.Easy, ...);
proxyViewMode.AddQuest("Calming the Wake", Images1, QuestDifficulty.Normal, ...);
proxyViewMode.AddQuest("Retaliation", Images2, QuestDifficulty.Hard, ...);
```

### Solution Comparison

| Feature | C++ Declaration | String + TS Enum |
|---------|----------------|------------------|
| Type Safety | âœ… Strong typing, UE reflection support | âš ï¸ Runtime is string |
| Development Efficiency | âš ï¸ Requires writing C++ code | âœ… Pure TypeScript, rapid iteration |
| Cross-language Usage | âœ… Works in C++, Blueprint, TS | âš ï¸ Mainly used in TS |
| XAML Display | âš ï¸ Needs converter | âœ… Displays string directly |
| Use Cases | Complex types, multi-use | Simple enums, logic layer use |

**Recommendation**: For simple enum values (like difficulty levels), use String + TS enum solution; for complex data structures or types widely used in C++ and Blueprint, use C++ declaration.

---

## âš¡ Performance Considerations

### Performance Characteristics

This solution **has not been stress-tested yet**, but from an architectural perspective:

**Performance Overhead Sources:**
1. **Cross-language Call Overhead**: TypeScript â†” C++ cross-language calls have some overhead
2. **Reflection and Static Blueprint Function Calls**: Property lookup via reflection is slower than calling NoesisGUI official APIs directly in C++
3. **NoesisProxy Interception**: JavaScript Proxy interception adds minor overhead

### Optimization Recommendations

**Development Phase: Prioritize TypeScript**

In early development, **strongly recommend using TypeScript**:
- âœ… High development efficiency, fast iteration
- âœ… Easy to modify and debug
- âœ… AI Coding friendly, auto-generates code
- âœ… Version control friendly, smooth team collaboration

**Optimization Phase: Convert to C++ Based on Performance Data**

When the project enters optimization phase, selectively convert bottleneck parts:
1. Perform performance analysis, identify bottleneck ViewModes
2. Convert high-frequency ViewModes to C++
3. Keep low-frequency ViewModes in TypeScript

**Core Philosophy**: Enjoy TypeScript's high efficiency in early development, then selectively convert bottleneck parts to C++ during optimization phase.

---

## ğŸ’¡ Development Suggestions

### 1. Use `tsc --watch` for Efficiency

During development, enable TypeScript's watch mode:

```bash
tsc --watch
```

This automatically compiles TypeScript files on save, eliminating manual `tsc` execution.

### 2. Leverage NoesisProxy

For frequently updated ViewModes, wrap them with NoesisProxy:

```typescript
const viewMode = NoesisViewUtils.createViewMode(viewModeClassPath);
const proxy = createNoesisProxy<TS_ButtonsViewMode>(viewMode);

// All subsequent modifications go through proxy
proxy.TestValue = "New Value";
```

### 3. Type Safety

TypeScript's type system primarily helps **during the writing phase**. Only members decorated with `@uproperty` and `@ufunction` will be generated as Blueprint reflection info by PuerTS.

### 4. Code Reuse

Encapsulate common logic into utility functions:

```typescript
// NoesisViewUtils.ts
export class NoesisViewUtils {
    public static createViewMode(classPath: string): UE.Object | null {
        const ViewModeClass = UE.Class.Load(classPath);
        return ViewModeClass ? UE.NewObject(ViewModeClass) : null;
    }

    // ... more utility methods
}
```

---

## ğŸ¤ Contributing and Contact

### Contributing

Issues and Pull Requests are welcome!

If you encounter problems or have suggestions, please let us know in [GitHub Issues](https://github.com/No-needto-recall/NoesisDemo/issues).

### Contact

- NoesisGUI Official Forum: [https://forums.noesisengine.com/](https://forums.noesisengine.com/)
- GitHub Issues: [https://github.com/No-needto-recall/NoesisDemo/issues](https://github.com/No-needto-recall/NoesisDemo/issues)

### License

This project is licensed under the MIT License.

### Acknowledgments

- [NoesisGUI](https://www.noesisengine.com/) - Powerful XAML UI framework
- [PuerTS](https://github.com/Tencent/puerts) - Excellent TypeScript runtime
- [Unreal Engine](https://www.unrealengine.com/) - World-leading game engine

---

<div align="center">

**Develop NoesisGUI with TypeScript, enjoy the pleasure of code-based development!**

Made with â¤ï¸ for NoesisGUI Community

</div>
